
:::::::::::::::::::::::::::::::::::: MI GU칈A ::::::::::::::::::::::::::::::::::::


> MEDIDAS DE SEGURIDAD PREVIAS

Primero que nada, no estar칤a mal verificar si el hash del .iso es el correcto; 
para ello, antes de ingresar al entorno de instalaci칩n, ejecutar (por ej.) 
'md5sum instalador_de_arch.iso' y comprobar si el hash coincide con el 
se침alado en https://archlinux.org/download/. Si est치s en un Windows tendr치s
que hacerlo de otra manera. O no hacerlo : )

Ahora bien, si eres de los paranoicos (y sobre todo si usas un m칩dem, en vez de 
un router, y por tanto no tienes el firewall de un router protegi칠ndote), 
quiz치s quieras desconectar el internet para iniciar el instalador deArch, 
luego desactivar el demonio sshd, para prevenir cualquier posible intrusi칩n al 
sistema live (ejecutar 'systemctl stop sshd.service') y entonces conectar 
la internet de nuevo.


> SELECCIONAR DISTRIBUCI칍N DE TECLADO

Bastar치 con ejecutar 'loadkeys es' para establecer el idioma espa침ol en el 
instalador de Arch (tener en cuenta que ese comando no servir치 para hacer lo 
mismo en el sistema que instalaremos; m치s adelante se explicar치 c칩mo hacerlo
en ese caso).

Por cierto que si se quisiera ver todas las distribuciones de teclado 
disponibles, puede ejecutarse el comando 'ls /usr/share/kbd/keymaps/**/*.map.gz'.


> VERIFICAR SI LA MODALIDAD DE ARRANQUE ES UEFI O BIOS/LEGACY

El instalador de Arch utiliza systemd-boot para arrancar en modo UEFI y syslinux
para arrancar en modo BIOS; saber en qu칠 modo se ha arrancado es importante para 
entender de qu칠 manera deberemos particionar y/o montar el filesystem despu칠s.

En caso de no tener claro de qu칠 manera boote칩 el sistema, para comprobarlo 
tocar치 listar el contenido de la carpeta "efivars", mediante el comando 
'ls /sys/firmware/efi/efivars'. Si la respuesta es que no existe tal directorio, 
el instalador est치 en modo BIOS, y si en cambio se lista el contenido del 
directorio, entonces est치 en modo UEFI.


> COMPROBAR LA CONEXI칍N A INTERNET

B치sicamente, bastar치 con hacer un ping a alguna url (ej. 'ping www.taringa.net') 
para ver si tenemos o no conexi칩n. Si tenemos internet cableada, seguramente ya
est칠 andando. 

Suele recomendarse actualizar la fecha y hora del sistema, para evitar problemas 
al conectarnos a los servidores de Arch. El comando a ejecutar es 
'timedatectl set-ntp true'. Para asegurarnos de que la hora qued칩 bien 
configurada, podemos ejecutar el comando 'timedatectl status'.

Puede pasar que vaya lenta la conexi칩n al servidor de Arch que estemos usando. 
En tal caso, se deber치 usar reflector para auto-seleccionar otro servidor mejor.
So, ejecutar los siguientes comandos:

'pacman -Sy'
'pacman -S reflector rsync'
'cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak'
'reflector --verbose -l 50 --sort rate --save /etc/pacman.d/mirrorlist'
'pacman -Syy'

El proceso de chequear 50 servidores y elegir el mejor tarda un rato, pero es la
칰nica soluci칩n que conozco, y REALMENTE necesaria si el fallo se da (la 
instalaci칩n puede correr a... 20kbps... me ha pasado, y m치s de una vez).

Por cierto, siempre puede ejecutarse el comando 'ip link' para ver qu칠 
dispositivo de red ha sido detectado en nuestro equipo. En la mayor칤a de sistemas, 
los dispositivos detectados aparecer치n como "enp(xxxx)" cuando sean de internet 
cableada, y "wlp(xxxx)" cuando sean inalambricos. Esto es 칰til para saber que no
se ha omitido ning칰n dispositivo que tengamos.

En cualquier caso, el instalador de Arch ejecuta por su cuenta el demonio/servicio 
dhcpcd, el cual se encarga de ejecutar el protocolo DHCP, que nos conectar치 a 
internet y nos brindar치 una IP din치mica. Pero en caso de que haber ocurrido 
cualquier tipo de problema, y vayamos a intentar resolverlo manualmente, 
deberemos ejecutar los siguientes comandos (estando conectados a internet):

'systemctl enable dhcpcd.service'
'systemctl enable dhcpcd@interface.service' (reemplazar "interface" por el nombre
de nuestro dispositivo de red)

Ahora, si se tiene una conexi칩n inalambrica, tocar치 ejecutar 'iwctl' para activar 
el wifi. Eso... lo agregar칠 alg칰n d칤a a la gu칤a, pero no ser치 hoy 游녨

> PARTICIONAR Y DAR FORMATO

Primero, se debe ejecutar 'fdisk -l' para ver qu칠 dispositivos ha reconocido el 
instalador de Arch. Lo normal ser치 ver al menos un disco duro tipo SATA (es decir, 
un dispositivo listado como "/dev/sda"). Y desde luego, si tiene particiones, 
aparecer치n como sda1, sda2, etc.

Primero, ejecutaremos el comando 'fdisk /dev/sdX'. Entraremos al prompt de fdisk, 
donde aplican comandos especiales, de una sola letra. Los esenciales son:

n = crear una partici칩n.
d = borrar una partici칩n.
l = listar los tipos de particiones.
p = muestra la tabla de partici칩n (similar a 'fdisk -l').
t = cambia el tipo de partici칩n.
m = muestra la lista de comandos disponible.
g = crea una tabla de partici칩n nueva de tipo GPT.
o = crea una tabla de partici칩n nueva de tipo DOS.
a = marca/desmarca una partici칩n tipo DOS con el flag "boot".

Ahora bien, en caso de que el disco est칠 vac칤o, tocar치 decidir qu칠 tipo de tabla 
de particiones queremos. Fundamentalmente tenemos las particiones tipo DOS 
(tambi칠n conocidas como "tipo BIOS" o "tipo legacy"), y las particiones tipo GPT 
(las que se han implementado con los sistemas Windows m치s modernos). Las GPT 
tienen la ventaja de que se puedan crear m치s de cuatro particiones primarias 
(a diferencia de en las tipo DOS), pero tiene el requisito de una partici칩n EFI 
al inicio del disco, que se sirven para arrancar la PC en modo UEFI, y tambi칠n 
la instalaci칩n es levemente m치s compleja.

As칤 pues, si el disco est치 vac칤o, o si queremos borrar todo, tocar치 ejecutar el 
comando 'g' para crear una tabla de particiones tipo GPT, o el comando 'o' para 
crear una tipo DOS. 

Si queremos crear una partici칩n, toca pulsar el comando 'n'. Si estamos en una 
tabla tipo DOS, se nos preguntar치 si crear una partici칩n primaria o extendida; 
elegir primaria. Luego se nos preguntar치 en qu칠 sector del disco debe empezar la 
partici칩n... pulsar simplemente enter, y se utilizar치 la opci칩n por default  
(situarla al principio del espacio libre en el disco). Luego se nos preguntar치 
donde debe acabar la partici칩n, y aqu칤 es donde viene lo 칰til, pues en vez de 
se침alar un sector, podremos se침alar la extensi칩n de la partici칩n en medidas m치s 
entendibles para nosotros; se trata de poner el signo m치s, y luego un n칰mero seguido 
de K, M, G o T, con lo cual si por ej. ponemos '+500M', estaremos creando una 
partici칩n de 500 megabytes.  

En principio, siempre habr치 que crear al menos una partici칩n, destinada al 
directorio ra칤z del sistema ("/"), y adem치s, tambi칠n es 칰til crear otra para montar 
home ("/home"), cosa que tiene su ventaja para que el d칤a que debamos reinstalar, no 
nos veamos obligados a mover todos nuestros archivos personales a otro lugar, sino 
que los podremos dejar tranquilos en /home, mientras reemplazamos el sistema en / por 
uno nuevo. Finalmente, si se desea se pueden hacer m치s particiones de uso general, 
y adem치s es posible crear una tipo swap (memoria de intercambio), si bien eso suele 
ser innecesario en PCs modernas con mucha RAM. Ahora bien, todas las particiones 
creadas aparecer치n como "tipo linux", pero si hemos creado una swap, habr치 que 
marcarla como tipo swap; para eso, ingresar el comando 't', seleccionar la 
partici칩n swap, y a la pregunta de qu칠 queremos hacer, teclear el comando 'L', que
nos mostrar치 la lista de tipos de partici칩n disponible; entonces pulsamos 'q' para
salir de la lista, e ingresamos el n칰mero de tipo de partici칩n correspondiente al 
swap (el 19). Por 칰ltimo, si estamos usando una tabla de particiones DOS, se debe 
marcar la partici칩n del sistema con el flag "boot".

Una vez creadas las particiones deseadas, tocar치 entrar el comando 'w' en fdisk, 
para grabar en disco todas las tareas que hemos configurado.

Finalizado todo esto, o bien sea que no hayamos necesitado crear particiones el paso
final ser치 formatearlas. En cuanto a la partici칩n del sistema, lo habitual es darle 
formato ext4, mediante el comando 'mkfs.ext4 /dev/sdaX' (X deber치 reemplazarse por 
el n칰mero de partici칩n correspondiente, desde luego). En cuanto a /home, si vas a 
formatearla, se le puede dar ext4 tambi칠n, aunque claro que hay m치s opciones v치lidas 
(en mi caso uso btrfs, 'mkfs.btrfs -f /dev/sdaX'). Y lo mismo deber치 hacerse con 
otras que hayamos creado. Si hay una swap, tocar치 ejecutar 'mkswap /dev/sdaX' para 
darle formato.


> MONTAR EL SISTEMA DE ARCHIVOS

Usaremos el directorio /mnt del instalador de Arch, para montar el sistema de 
archivos de nuestro futuro sistema operativo, cosa necesaria para instalarlo y 
realizarle configuraciones diversas. La que ser치 la partici칩n del sistema, se 
montar치 directamente en /mnt. Y si pensamos usar una partici칩n para /home, 
entonces deberemos crearle una carpeta correspondiente en /mnt, ejecutando 
'mkdir /mnt/home', en la cual se montar치 /home. Por tanto los comandos ser치n:

'mount /dev/sdaX /mnt'

'mkdir /mnt/home && mount /dev/sdaX /mnt/home' (opcional, en caso de querer 
un /home) 

En caso de usar UEFI, tocar치 adem치s hacer entonces:

'mkdir /mnt/boot/efi'
'mount /dev/sdaX /mnt/boot/efi' (normalmente ser치 sda1)

Si hemos creado una partici칩n para el swap, habr치 que activarlo ahora, mediante 
el comando 'swapon /dev/sdaX.


> INSTALAR EL SISTEMA

En este caso, simplemente deberemos ir ejecutando diversos comandos, utilizando el
script "pacstrap". El software que vayas a instalar depende puramente de tus 
preferencias, pero es indispensable al menos un kernel (el paquete "linux", u otro
como "linux-lts"), el paquete "base" y "linux-firmware", un editor de texto (ej. 
"nano" o "vim") y adem치s "networkmanager", y el paquete "amd-ucode" o "intel-ucode" 
(seg칰n sea tu caso, dado el microprocesador que tengas).

Algo importante: 'pacman -S archlinux-keyring'. Esto actualiza el dep칩sito de claves
del sistema live, sin lo cual la descarga de algunos paquetes puede fallar sin remedio.

Ahora, a modo de ejemplo, dejar칠 aqu칤 las cosas que yo instalo. Pero esto es puramente 
ilustrativo, t칰 elige lo que quieras:

# lo fundamental
'pacstrap /mnt base linux-lts linux-firmware linux-lts-headers amd-ucode'

# paquetes de administraci칩n, hardening y mantenimiento
'pacstrap /mnt ufw rkhunter nethogs cpulimit lynis testdisk rsync fail2ban pkgstats nfs-utils xdg-user-dirs syslog-ng memtest86+ btrfs-progs apparmor clamav smartmontools dosfstools mtools arch-audit libpwquality ntp'

# paquetes de utilidades de usuario
'pacstrap /mnt nano mc ranger elinks htop mediainfo tree wget screenfetch dialog zip p7zip unrar vim gdu fuseiso ncdu freeimage cmatrix perl-image-exiftool cdrtools'

# paquetes de utilidades para internet
'pacstrap /mnt networkmanager dhcpcd iputils iproute2 nmap net-tools openssh bind traceroute arp-scan'

# paquetes de utilidades de audio
'pacstrap /mnt pulseaudio pulseaudio-alsa alsa-utils alsa-plugins cmus'

# paquetes de instalaci칩n de software
'pacstrap /mnt base-devel check git go cmake python-setuptools qt5-tools gcc make perl'

# paquetes documentaci칩n
'pacstrap /mnt man-db man-pages texinfo arch-wiki-lite' 

# el paquete de grub
'pacstrap /mnt grub-bios' (si tenemos BIOS Legacy)
'pacstrap /mnt grub' (si tenemos UEFI)

# paquetes necesarios si usaremos Linux junto a un Windows
'pacstrap /mnt os-prober ntfs-3g'

# paquete para conectar a internet via wifi
'pacstrap /mnt netctl wpa_supplicant'

# paquete de driver para los touchpad, si usaremos una laptop
'pacstrap /mnt xf86-input-synaptics'

# paquetes de Xorg, LightDM y Cinnamon? [yes/no] " var1
'pacstrap /mnt xorg xorg-xinit xorg-twm xterm libxkbcommon feh xf86-video-ati lightdm lightdm-gtk-greeter cinnamon'

# mis paquetes de software b치sico para entorno gr치fico
'pacstrap /mnt firefox libreoffice keepassxc kolourpaint xed gnote gnome-screenshot flameshot psensor gparted terminator easytag mediainfo-gui vlc mpv  transmission-gtk file-roller xreader gnome-system-monitor gnome-calculator simplescreenrecorder arch-audit-gtk nomacs viu'

# mis paquetes de software extra para entorno gr치fico (adem치s de fuentes)
'pacstrap /mnt chromium adobe-source-sans-pro-fonts ttf-freefont enchant gst-libav languagetool gvfs gimp mate-icon-theme minitube clipgrab audacity totem smplayer oxygen-icons noto-fonts-emoji unicode-emoji ttf-dejavu adobe-source-han-serif-jp-fonts adobe-source-han-sans-jp-fonts notepadqq'


CONFIGURACIONES

Ahora, vamos a generar un archivo fstab, el cual se encarga de gestionar el acceso 
automatizado a las particiones (esencialmente, a /, y adem치s -si las tenemos- a 
 /home, a swap y cualquier otra que especifiquemos). As칤, las particiones 
incluidas ser치n montadas por el sistema, sin nuestra intervenci칩n. El comando a 
ejecutar es 'genfstab -U /mnt >> /mnt/etc/fstab'. Podemos hacer si queremos luego
'nano /mnt/etc/fstab' para comprobar que el archivo se haya creado seg칰n lo 
previsto, o editarlo como se prefiera.

Para lo siguiente, deberemos realizar una tarea algo m치s especializada, que es 
ingresar desde el live cd al sistema que acabamos de instalar; es decir, vamos a
acceder a su propio prompt y utilizar por primera vez nuestro nuevo Arch. Para 
esto, ejecutaremos el comando 'arch-chroot /mnt'.

Una vez ah칤, lo primero ser치 configurar la zona horaria para nuestro sistema. El
comando ser치, en mi caso:

'ln -sf /usr/share/zoneinfo/America/Buenos_Aires /etc/localtime'

Por supuesto, esto variar치 seg칰n donde est칠 cada quien.

Ahora, ejecutaremos 'hwclock --systohc' para tener la hora sincronizada con 
nuestro horario local. Podemos ejecutar luego 'date' para comprobar que todo sea
correcto.

Lo siguiente ser치 definir el idioma del sistema, cosa que haremos editando 
'/etc/locale.gen' (con nano, vim o lo que sea) y lo que debemos hacer es borrar 
los signos numeral delante de las lineas "es_ES.UTF-8 UTF-8" (o las que prefiramos,
yo por ej. des-comento tambi칠n "en_US.UTF-8 UTF-8"). Para buscarlas r치pidamente con 
nano, ejecutar "ctrl + w" (que toca repetir para cada vez que se quiera buscar algo, 
presionando enter, claro). Al borrar los "#", lo que hacemos es des-comentar esas 
l칤neas, por lo que pasan a ser c칩digo activo de los archivos. Hecho esto, ha de 
ejecutarse el comando 'locale-gen' para que la edici칩n hecha surta efecto. 

Aunque con el paso anterior se habilit칩 una o m치s variantes para ser usadas, aun 
tendremos que editar otro fichero m치s, para elegir la variante deseada (en mi caso, 
espa침ol de Espa침a). Toca ejecutar 'nano /etc/locale.conf' para ello, lo que crear치 
el fichero; all칤 escribiremos el texto correspondiente (en mi caso "LANG=es_ES.UTF-8").

Hecho esto, lo siguiente ser치 fijar el idioma de la distribuci칩n de teclado. Aunque 
para el live cd la orden hab칤a sido 'loadkeys es', en este caso lo que haremos ser치 
ejecutar 'nano /etc/vconsole.conf' (lo que una vez m치s, crear치 el archivo), y ah칤 se 
deber치 escribir "KEYMAP=es". La raz칩n de tener que hacer esto es que el efecto
de loadkeys, s칩lo dura mientras el equipo no se reinicie.

Ahora tocar치 hacer algunos ajustes de red.

B치sicamente, tocar치 definir el hostname. Para eso, crearemos el archivo 
correspondiente v칤a 'nano /etc/hostname', en donde 칰nicamente escribiremos el 
nombre que vayamos a darle al equipo en la red. Luego, tocar치 ejecutar
'nano /etc/hosts' y ah칤 escribir lo siguiente:

127.0.0.1	localhost
::1         localhost
127.0.1.1	nombre-elegido-para-el-hostname

Hecho eso, seguir치 ahora un punto fundamental: instalar y configurar el grub. Sin 
esto el sistema b치sicamente no arrancar치. El comando de instalaci칩n variar치 seg칰n 
estemos usando BIOS o UEFI. 

Si usas BIOS Legacy: 'grub-install /dev/sda' (si el disco no fuera "sda", cambiarlo 
por el correspondiente; es importante notar que hay que se침alar el disco en si, no 
un n칰mero de partici칩n en espec칤fico, como sda1 o sdb1).

Si usas UEFI: 'grub-install --efi-directory=/boot/efi --bootloader-id='Arch Linux' --target=x86_64-efi'

Luego, en cualquiera de los dos casos, ejecutar 
'grub-mkconfig -o /boot/grub/grub.cfg', que actualizar치 el grub. En caso de no 
haber reportado que encontrara un Windows que tengamos en el equipo, ejecutar 
'os-prober' y luego nuevamente 'grub-mkconfig -o /boot/grub/grub.cfg'.

Y as칤 habremos llegado casi al final. Lo 칰ltimo ser치 ejecutar 'passwd' para 
asignar una password a root, y entonces la instalaci칩n habr치 finalizado.

Tras eso, toca salir del prompt del sistema instalado, mediante 'exit' y desmontar 
las particiones que se hayan montado en /mnt. Luego ya se podr치 reiniciar y probar 
el sistema nuevo. Pero algo importante: NO recomiendo NUNCA iniciar el sistema nuevo 
conectado a internet, hasta haber implementado al menos algunas medidas b치sicas de 
seguridad (cuanto menos iniciar el firewall, por el amor de Cthulhu xd). No detallar칠
aqu칤 medidas de hardening, pero puedes ver la gu칤a de Arch al respecto, en 
https://wiki.archlinux.org/title/Security (est치 bastante incompleta, a mi juicio, so
deber칤as complementarla con otras; m치s adelante yo subir칠 mi propia gu칤a tambi칠n); 
tambi칠n puedes ejecutar los auditores Lynis y Yasat para ir resolviendo problemas.


> ALGUNAS TAREAS POST REINICIO

Iniciar el firewall:

'systemctl start ufw.service'

'systemctl enable ufw.service'

'ufw status' (opcional, se comprobar치 que aun no est치 activo SABER QU칄 EST츼)

'ufw enable'


> iniciar networkmanager

'systemctl start NetworkManager.service' (si, en mayusculas)

'systemctl enable NetworkManager.service' (idem)

Si hubiera problemas al instalar o actualizar software, donde nos de un mensaje
de "error 404", ejecutar 'pacman -Syyuu'; este error aparecer치 en cualquier 
momento.


> a침adir otros usuarios al sistema

'groupadd tu_grupo'
'useradd -m -g tu_grupo -G audio,video,storage,games -s /bin/bash tu_usuario'


> configurar la distribuci칩n de teclado para Xorg

'localectl set-x11-keymap es' 


> iniciar lightdm (opcional)

'systemctl enable lightdm'

Notar que a diferencia de otras ocasiones, no hemos hecho la orden "start",
sino tan solo "enable", y eso tiene una raz칩n de ser: si hacemos start, 
entonces lightdm se ejecutar치 en ese mismo momento, apareciendo en pantalla
y oblig치ndonos a entrar sesi칩n (aunque podemos abrir otra tty -terminal- 
haciendo ctrl+alt+f2). 


> hacer una copia de seguridad del sistema

Por si revientas tu nuevo Arch, nada mejor que echar mano a 칠l otra vez sin tener 
que pasar por todo el sufrimiento de una re-instalaci칩n : )

Recomiendo usar Macrium Reflect. B칰scalo "por ah칤" xD (si me contactas te lo puedo pasar).

Con Linux, se puede usar el software rsync. Si se quieren copias inteligentes (que 
copien todo la primera vez, y en adelante, s칩lo lo que ha sido modificado). Su 
sintaxis es:

rsync -aAXlv --delete --exclude=XXXX origen destino

Para copiar nuestra partici칩n del sistema, recomiendo iniciar un sistema live y 
crear dos carpetas en /mnt, disco1 y disco2, y montar en la primera nuestra partici칩n
del sistema y en la segunda la partici칩n donde lo copiaremos. En ese caso, el comando
ser칤a:

rsync -aAXlv --delete --exclude=/dev --exclude=/run --exclude=/sys --exclude=/proc --exclude=/tmp --exclude=/mnt --exclude=/media --exclude=/home --exclude=swapfile --exclude=lost+found /mnt/prueba1 /mnt/prueba2

Si el lugar donde guardaremos la copia de seguridad NO es privado, y puede ser 
accedido por users est치ndar, recomiendo excluir tambi칠n la carpeta personal de root, 
a fin de que sus archivos privados no se vean expuestos.


